import type {
  DocumentNode,
  FieldNode,
  FragmentDefinitionNode,
  OperationDefinitionNode,
  SelectionSetNode,
  VariableDefinitionNode,
} from "graphql";

/**
 * Options for generating TypeScript types.
 */
export interface TypeGeneratorOptions {
  /**
   * Enable fragment masking.
   * When enabled, fragment spreads in queries become opaque refs.
   */
  fragmentMasking?: boolean;

  /**
   * Document node to generate types for.
   */
  document: DocumentNode;

  /**
   * Source file path.
   */
  sourcePath: string;
}

/**
 * Information about a parsed fragment spread.
 */
interface FragmentSpreadInfo {
  name: string;
  onType: string;
}

/**
 * Information about a parsed field.
 */
interface FieldInfo {
  name: string;
  alias?: string;
  hasSelections: boolean;
  isArray: boolean;
}

/**
 * Extract fragment definitions from a document.
 */
function getFragmentDefinitions(document: DocumentNode): Map<string, FragmentDefinitionNode> {
  const fragments = new Map<string, FragmentDefinitionNode>();
  for (const def of document.definitions) {
    if (def.kind === "FragmentDefinition") {
      fragments.set(def.name.value, def);
    }
  }
  return fragments;
}

/**
 * Extract fragment spreads from a selection set.
 */
function getFragmentSpreads(
  selectionSet: SelectionSetNode,
  fragments: Map<string, FragmentDefinitionNode>,
): FragmentSpreadInfo[] {
  const spreads: FragmentSpreadInfo[] = [];

  for (const selection of selectionSet.selections) {
    if (selection.kind === "FragmentSpread") {
      const fragDef = fragments.get(selection.name.value);
      spreads.push({
        name: selection.name.value,
        onType: fragDef?.typeCondition.name.value ?? "unknown",
      });
    } else if (selection.kind === "Field" && selection.selectionSet) {
      // Recursively check nested fields
      spreads.push(...getFragmentSpreads(selection.selectionSet, fragments));
    } else if (selection.kind === "InlineFragment" && selection.selectionSet) {
      spreads.push(...getFragmentSpreads(selection.selectionSet, fragments));
    }
  }

  return spreads;
}

/**
 * Extract direct fields from a selection set (not from fragment spreads).
 */
function getDirectFields(selectionSet: SelectionSetNode): FieldInfo[] {
  const fields: FieldInfo[] = [];

  for (const selection of selectionSet.selections) {
    if (selection.kind === "Field") {
      const field = selection as FieldNode;
      fields.push({
        name: field.name.value,
        alias: field.alias?.value,
        hasSelections: !!field.selectionSet,
        isArray: false, // Would need schema to determine
      });
    }
  }

  return fields;
}

/**
 * Map GraphQL type to TypeScript type.
 */
function mapVariableType(typeName: string): string {
  switch (typeName) {
    case "String":
      return "string";
    case "Int":
    case "Float":
      return "number";
    case "Boolean":
      return "boolean";
    case "ID":
      return "string";
    default:
      return "unknown";
  }
}

/**
 * Extract variable type from a variable definition.
 */
function getVariableType(varDef: VariableDefinitionNode): { type: string; required: boolean } {
  let type = varDef.type;
  let required = false;

  // Handle NonNullType
  if (type.kind === "NonNullType") {
    required = true;
    type = type.type;
  }

  // Handle ListType
  if (type.kind === "ListType") {
    const innerType = type.type;
    if (innerType.kind === "NamedType") {
      return { type: `${mapVariableType(innerType.name.value)}[]`, required };
    }
    return { type: "unknown[]", required };
  }

  // Handle NamedType
  if (type.kind === "NamedType") {
    return { type: mapVariableType(type.name.value), required };
  }

  return { type: "unknown", required };
}

/**
 * Generate TypeScript type declarations for a GraphQL document.
 */
export function generateTypeDeclarations(options: TypeGeneratorOptions): string {
  const { document, sourcePath, fragmentMasking = true } = options;

  const lines: string[] = [];
  const modulePath = sourcePath.replace(/\.(graphql|gql)$/, "");
  const fragments = getFragmentDefinitions(document);

  lines.push(`// Auto-generated types for ${sourcePath}`);
  lines.push(`// Do not edit this file directly`);
  lines.push("");

  lines.push(`declare module '${modulePath}' {`);
  lines.push(
    `  import type { TypedDocumentNode, TypedFragmentNode, FragmentRef } from '@pinia-colada-graphql/core'`,
  );
  lines.push("");

  // First, generate fragment types
  for (const [fragName, fragDef] of fragments) {
    const onType = fragDef.typeCondition.name.value;
    const fields = getDirectFields(fragDef.selectionSet);

    lines.push(`  /** Fragment data type for ${fragName} */`);
    lines.push(`  export interface ${fragName}Data {`);
    lines.push(`    __typename: '${onType}'`);
    for (const field of fields) {
      const fieldName = field.alias ?? field.name;
      lines.push(`    ${fieldName}: unknown`);
    }
    lines.push(`  }`);
    lines.push("");

    lines.push(`  /** Fragment document for ${fragName} */`);
    lines.push(`  export const ${fragName}: TypedFragmentNode<${fragName}Data, '${fragName}'>`);
    lines.push("");

    // Generate the $key type for fragment refs
    lines.push(`  /** Fragment reference type for ${fragName} */`);
    lines.push(`  export type ${fragName}$key = FragmentRef<'${fragName}', '${onType}'> & {`);
    lines.push(`    readonly ' $fragmentRefs'?: ${fragName}Data`);
    lines.push(`  }`);
    lines.push("");
  }

  // Generate operation types
  for (const definition of document.definitions) {
    if (definition.kind === "OperationDefinition") {
      const opDef = definition as OperationDefinitionNode;
      const opName = opDef.name?.value ?? "Anonymous";
      const opType = opDef.operation;

      // Get fragment spreads in this operation
      const spreads = opDef.selectionSet ? getFragmentSpreads(opDef.selectionSet, fragments) : [];

      // Get direct fields
      const directFields = opDef.selectionSet ? getDirectFields(opDef.selectionSet) : [];

      // Generate result type
      lines.push(`  /** Result type for ${opName} ${opType} */`);
      lines.push(`  export interface ${opName}Result {`);

      if (directFields.length === 0 && spreads.length === 0) {
        lines.push(`    [key: string]: unknown`);
      } else {
        // For each direct field, generate a type
        for (const field of directFields) {
          const fieldName = field.alias ?? field.name;
          if (field.hasSelections) {
            // Check if this field has fragment spreads
            // For simplicity, mark as unknown for now
            lines.push(`    ${fieldName}: unknown`);
          } else {
            lines.push(`    ${fieldName}: unknown`);
          }
        }

        // If fragment masking is enabled, add fragment ref markers
        if (fragmentMasking && spreads.length > 0) {
          lines.push(`    // Data masking: access fragment data via useFragment()`);
          for (const spread of spreads) {
            lines.push(`    ' $fragmentRefs'?: {`);
            lines.push(`      '${spread.name}': ${spread.name}Data`);
            lines.push(`    }`);
          }
        }
      }

      lines.push(`  }`);
      lines.push("");

      // Generate variables type
      lines.push(`  /** Variables type for ${opName} ${opType} */`);
      lines.push(`  export interface ${opName}Variables {`);
      if (opDef.variableDefinitions && opDef.variableDefinitions.length > 0) {
        for (const varDef of opDef.variableDefinitions) {
          const varName = varDef.variable.name.value;
          const { type, required } = getVariableType(varDef);
          lines.push(`    ${varName}${required ? "" : "?"}: ${type}`);
        }
      } else {
        lines.push(`    // No variables`);
      }
      lines.push(`  }`);
      lines.push("");

      // Generate document constant
      lines.push(`  /** Typed document for ${opName} ${opType} */`);
      lines.push(
        `  export const ${opName}: TypedDocumentNode<${opName}Result, ${opName}Variables>`,
      );
      lines.push("");

      if (opType === "query" || opType === "mutation") {
        lines.push(`  export default ${opName}`);
        lines.push("");
      }
    }
  }

  lines.push("}");

  return lines.join("\n");
}

/**
 * Generate a combined types file for all GraphQL documents.
 */
export function generateCombinedTypes(
  documents: Map<string, DocumentNode>,
  options: { fragmentMasking?: boolean } = {},
): string {
  const { fragmentMasking = true } = options;
  const lines: string[] = [];

  // Collect all fragments across documents
  const allFragments = new Map<string, { def: FragmentDefinitionNode; source: string }>();
  for (const [path, document] of documents) {
    for (const def of document.definitions) {
      if (def.kind === "FragmentDefinition") {
        allFragments.set(def.name.value, { def, source: path });
      }
    }
  }

  lines.push(`// Auto-generated GraphQL types`);
  lines.push(`// Do not edit this file directly`);
  lines.push("");
  lines.push(
    `import type { TypedDocumentNode, TypedFragmentNode, FragmentRef } from '@pinia-colada-graphql/core'`,
  );
  lines.push("");

  // Generate fragment types first (they may be referenced by operations)
  if (allFragments.size > 0) {
    lines.push(`// ============================================`);
    lines.push(`// Fragment Types`);
    lines.push(`// ============================================`);
    lines.push("");

    for (const [fragName, { def: fragDef, source }] of allFragments) {
      const onType = fragDef.typeCondition.name.value;
      const fields = getDirectFields(fragDef.selectionSet);

      lines.push(`// Fragment: ${fragName} (from ${source})`);
      lines.push("");

      lines.push(`export interface ${fragName}Data {`);
      lines.push(`  __typename: '${onType}'`);
      for (const field of fields) {
        const fieldName = field.alias ?? field.name;
        lines.push(`  ${fieldName}: unknown`);
      }
      lines.push(`}`);
      lines.push("");

      lines.push(
        `export type ${fragName}Fragment = TypedFragmentNode<${fragName}Data, '${fragName}'>`,
      );
      lines.push("");

      lines.push(`export type ${fragName}$key = FragmentRef<'${fragName}', '${onType}'> & {`);
      lines.push(`  readonly ' $fragmentRefs'?: ${fragName}Data`);
      lines.push(`}`);
      lines.push("");
    }
  }

  // Generate operation types
  lines.push(`// ============================================`);
  lines.push(`// Operation Types`);
  lines.push(`// ============================================`);
  lines.push("");

  for (const [path, document] of documents) {
    const fragments = getFragmentDefinitions(document);

    for (const definition of document.definitions) {
      if (definition.kind === "OperationDefinition") {
        const opDef = definition as OperationDefinitionNode;
        const opName = opDef.name?.value ?? "Anonymous";
        const opType = opDef.operation;

        lines.push(`// ${opType}: ${opName} (from ${path})`);
        lines.push("");

        // Get fragment spreads
        const spreads = opDef.selectionSet
          ? getFragmentSpreads(
              opDef.selectionSet,
              new Map(
                [...fragments, ...allFragments.entries()].map(([k, v]) => [
                  k,
                  "def" in v ? v.def : v,
                ]),
              ),
            )
          : [];

        // Generate result interface
        lines.push(`export interface ${opName}Result {`);
        lines.push(`  [key: string]: unknown`);
        if (fragmentMasking && spreads.length > 0) {
          lines.push(`  // Fragment refs (use useFragment to access)`);
          for (const spread of spreads) {
            lines.push(`  ' $fragmentRefs'?: {`);
            lines.push(`    '${spread.name}': ${spread.name}Data`);
            lines.push(`  }`);
          }
        }
        lines.push(`}`);
        lines.push("");

        // Generate variables interface
        lines.push(`export interface ${opName}Variables {`);
        if (opDef.variableDefinitions && opDef.variableDefinitions.length > 0) {
          for (const varDef of opDef.variableDefinitions) {
            const varName = varDef.variable.name.value;
            const { type, required } = getVariableType(varDef);
            lines.push(`  ${varName}${required ? "" : "?"}: ${type}`);
          }
        }
        lines.push(`}`);
        lines.push("");

        lines.push(
          `export type ${opName}Document = TypedDocumentNode<${opName}Result, ${opName}Variables>`,
        );
        lines.push("");
      }
    }
  }

  return lines.join("\n");
}
